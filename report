1) regexp.MatchString съедал по 1 сек времени, я поменял его на strings.Contains
Регулярные выражения гораздо более ресурсоемкие чем аналоги и пакета strings
regexp нужно использовать только тогда когда не справляются strings функции

по этой же логике я заменил MustCompile--ReplaceAllString на strings.Replace


2) При листинге функции быстрого поиска я заметил что конкатенация строк foundUsers съедает по 800кб памяти, я заменил конкатенацию на stringBuilder
Конкатенация создает новые строки каждый раз, стринг билдер создает строку всего 1 раз, только при вызове String()
Чуть позже развивая эту оптимизацию я поменял формат. вывод на стринг билдер с конвертацией itoa


3) стандартный пакет json создает объекты пакета рефлексии, из-за этого съедает очень много памяти и 600ms времени.
Альтернатива рефлексии - кодогенерация, например библиотека easyjson
Я создал структуру myUser для данного json файла, и с помощью кодогенерации получил выигрыш по быстродействию почти в 6 раз
В структуре myUser из 7 полей в функции поиска используется всего 3, я закоментировал неиспользуемые поля, тем самым получил прибавку в скорости 20% и сокращение количества аллокаций на 30%

4) Больше всего памяти съедало чтение из файла - 11mb, еще 2.8mb тратилось на конвертацию слайса байт в строку (которые снова будут конвертироваться в слайс байт для json) и сплит
Альтернатива readAll - reader.ReadLine, он считывает построчно - нет необходимости конвертации в строки ради сплита

5) Аппенды users и seenBrowsers вызывали по 70kb и 10kb
Проблема заключалась в капасити которая была задана нулем, при переполнении капасити аллоцируется новый слайс с капасити old*2, ставим в конструкторе значение капасити 1000 по количеству строк json файла



текущие результаты:

BenchmarkSlow-6                2         596224872 ns/op        19569676 B/op     189802 allocs/op
BenchmarkFast-6               73          17435005 ns/op          553650 B/op       7170 allocs/op
